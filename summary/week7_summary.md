# Week 7 - 구현

### 프로그래밍 언어의 역사

* **포트란(FORTRAN : FORmula TRANslation)**
    * 1954년 11월 만들어져 1956년 10월 포트란1로 발표됨
    * **초창기 고급 언어(High Level Language)**
    * IBM이 우주항공 분야에서 사용하기 위해 만듦
* **베이직(BASIC : Beginner's All-purpose Symbolic Instruction Code)**
    * **교육용으로 만들어진 언어**, 포트란1을 토대로 Algol60을 거쳐 1964년 만들어짐
    * 비주얼 베이직1.0(1991)은 MS가 만든 GUI에서 고속 응용 프로그램 개발(RAD, Rapid Application Development)을 가능하게 해줌
    * 비주얼 베이직은 지원 종료, VB.NET이 뒤를 이음
* **C**
    * **가장 널리 쓰이는 명령형 언어**
    * 포트란1, 알골 60을 거쳐 AT&T 벨 연구소에서 일하던 데니스 리치(Dennis Ritchie)가 1971년 만듦
    * 대다수 컴퓨터 구조와 운영체제가 C 컴파일러를 갖고 있어 거의 모든 환경에서 사용 가능
    * C++, object-C, PHP 등 많은 언어의 토대가 됨
* **C++**
    * **C언어에 객체지향의 개념을 더한 언어**
    * AT&T 벨 연구소에서 일하던 비야네 스트롭스트룹(Bjarne Stroustrup)이 만듦
    * 원래 이름은 C with Classes 였으나 증가연산자(++)기능을 더하면서 1984년 이름이 바뀜
* **C#**
    * C언어를 토대로 오브젝트-C와 자바2를 거쳐 C#이 만들어짐
    * **MS가 닷넷 프레임워크의 일부로 만든 객체지향 프로그래밍  언어**
    * 닷넷 프로그램이 작동하는 닷넷 플랫폼을 가장 직접적으로 반영하여 크게 의존
    * 자바와 달리 서로 다양한 플랫폼에서 사용할 수 있도록 하는 데 노력을 기울이고 있음
* **자바**
    * **선 마이크로시스템즈(Sun Microsystems)의 제임스 고슬링(James Gosling)이 개발한 객체지향 언어**
    * 자바는 C언어를 토대로 오브젝트-C를 거쳐 기계의 운영체제와 무관하게 실행할 수 있도록 만들어짐
    * 처음엔 오크(Oak)로 불렸으나 같은 이름이 존재해 자바로 바꿈
    * JVM(Java Virtual Machine)이라는 프로그램을 사용하기 때문에 컴파일된 코드가 각각의 플랫폼에 대해 독립적
        * 자바로 개발된 프로그램은 JVM을 설치할 수 있는 시스템이면 어디서든 실행가능하여 인기를 끎
    * 2009년 4월 선 마이크로시스템즈가 오라클에 인수 합병되어 자바에 대한 권리 및 유지보수도 오라클(Orcale)로 넘어감


### 코딩

* **코딩이란 프로그램을 작성하는 것**
* 요구 분석 후 생성되는 개체-관계 다이어그램(ERD), 클래스 다이어그램처럼 설계 과정에서 생성된 설계 명세서를 입력 데이터로 활용하여 원시 코드를 만들어 내는 것
* **표준 코딩 규칙을 따를 때의 장점**
  * **가독성이 높아짐**
    * 주석, 적절한 줄 바꿈 및 공백 사용, 들여쓰기
  * **간결하고 명확한 코딩이 가능**
      * 코드가 간결하고 명확하게 작성하면 읽기 쉽고 이해하기 쉽고 특정 부분을 찾아 변경하기 용이하여 유지보수가 쉬워짐
  * **개발 시간을 단축**

* [BSD vs K&R Coding Style](https://namu.wiki/w/%EC%BD%94%EB%94%A9%20%EC%8A%A4%ED%83%80%EC%9D%BC)

![code_style](https://github.com/ohbokdong/SoftwareEngineeringStudy/blob/master/summary/img/week7/code_style.jpg?raw=true)

### **명칭에 관한 규칙**

* **클래스명, 변수명, 함수명 같은 명칭은 31자 이내로 정함**
* **변수명과 함수명은 다르게 사용**
* **명칭의 규칙을 따름**
    * 명칭이 호환되도록 특수 문자는 '_'만 사용, 대소문자 사용규칙을 따름
    * 매크로명, 상수명 - '_' 및 대문자 사용
    * 변수명 - 소문자로 시작
    * 함수명 - 소문자로 시작, 첫 번째 단어는 동사로 작성
    * 포인터명 - 참조하는 변수명의 첫 글자는 대문자 사용

```c++
int num_sum = 0; // 허용된 특수 문자 사용
#define SIZE 10 // 매크로명 대문자 사용
const int HEIGHT = 20; // 상수명에 대문자 사용
int sum = 0; // 변수명이 소문자로 시작
int getData() { } // 함수명 소문자로 시작, 동사로 시작
```

* 포인터 변수명은 앞에 p를 붙임

```c++
int a, sum = 0;
int *pSum += a;
```

### 소스 형식에 관한 규칙

* **소스 파일 하나는 2000줄 이내로 작성**
* **한 줄의 길이는 80자 이내로 작성**
* 함수의 내용은 70줄 이내로 작성
* 여는 중괄호 {는 문장의 끝에, 닫는 중괄호 }는 문장의 시작에 둠

```c++
if (a > b) {
// 이렇게
}
```

* 하나의 문장을 2줄로 작성하는 경우
    * 80자가 넘어 쉼표(,)가 오면 다음 문자는 새 줄로 시작
    * 둘째 줄의 시작은 이전 줄의 표현식과 같게 함

``` c++
int a = k(parameter_A, parameter_B,
        parameter_C)
```

* **수준이 동일한 문장은 시작 위치를 맞춤**


### 주석에 관한 규칙

* 코드의 첫 주석에는 '최초 작성자, 최초 작성일, 최초 변경일, 목적, 개정 이력, 저작권'을 담는다


``` c++
/* 최초 작성자 : 홍길동
* 최초 작성일 : 2000.00.00
* 최초 변경일 : 2000.00.00
* 목적 : 성적 프로그램
* 개정 이력 : 홍길동, 2000.00.00.(ver. 01)
            홍길동, 2000.00.00.(ver. 02)
* 저작권 : 길동Company
*/ 
class grade {
...
}
```

* 함수(메서드) 정의 앞에 '목적, 매개변수, 변환 값, 변경 이력'을 주석으로 추가하고 시작


```c++
/* 목적 : 등급 구하기
* 매개변수 : kor(국어 점수)
        eng(영어 점수)
        mat(수학 점수)
* 반환 값 : grade(등급-A, B, C, D, F)
* 변경 이력 : 홍길동, 2000.00.00.(ver. 01)
            홍길동, 2000.00.00.(ver. 02)
*/
char getRank() {
...
}
```

* 원시 코드와 주석을 명확히 구분
    * 공백(또는 탭)을 두고 주석을 작성해서 가독성 높임
* 원시 코드와 주석이 일치하게 함
    * **주석도 유지보수를 해줘야 함**

### 변수 선언 및 자료형에 관한 규칙

* 용도가 같은 변수는 한 줄에 작성

```c++
int a=0, int b=0;
```

* **필요한 변수만 선언**
* **배열 선언 시 요소 수를 명시하거나 초기화**

```c++
int score[5];
int score[] = {1, 4, 7, 9, 10};
```

* 배열을 초기화할 때는 중괄호를 적절히 사용

```c++
int score[2][2] = { {1,4}, {7,9} };
```

* **지역 변수는 선언 시 초기화**
    * 초기화를 안하면 쓰레기값으로 초기화될 수 있음
* **부호 없는 자료형은 끝에 u를 붙임**

```c++
#define MIN 10u;
```

* **포인터 변수에 주소나 정수 값을 저장할 때는 자료형이 일치해야 함**

```c++
int * im;
int chi = 5;
pKim = &chi;
```

* **비트 필드는 unsigned/signed int형으로만 선언**

```c++
struct st {
unsigned int a : 2; // 비트 필드에 unsigned int형 사용
unsigned int b : 3; // 비트 필드에 unsigned int형 사용
};
```

* **비트 연산자는 부호있는 자료에 사용하지 않음**
  * 비트 연산자는 부호의 의미를 포함하지 않으므로,부호있는 연산자에 시프트 연산을 하게 되면 부호 비트와 숫자 값을 가지는 비트가 그 의미를 잃음

```java
unsigned int j = 10;
unsinged int k = j << 2;//양수에 비트연산자 적용.
```

### 상수에 관한 규칙
* **8진수는 사용하지 않음**
    * 상수를 표현할 때는 가독성을 위해 10진수나 16진수 표기법을 사용하는 것이 좋음

```c++
int hex = 0xFF; // 16진수
int chi = 10; // 10진수
```

* **숫자 리터럴을 직접적으로 소스코드 안에 삽입하지 않음**
  * 반복문의 카운터로 사용될 수 있는 (-1,0,1)을 제외한 숫자는 가독성을 저하시킴
  * 소스코드에 직접 기술한 숫자 리터럴은 그 의미를 파악하기 어려움

```c++
// 계산될 숫자를 미리 선언
const int base_line = 10;
const int height = 5;
int tri_area = base_line * iehgt / 2
```

* 상수는 부호에 있는 자료형을 사용하고 부호 없는 자료형을 사용할 때는 u를 붙임
    * 상수는 부호 있는 자료형을 기본으로함, 만약 부호가 없으면 u를 붙여 사용

```c++
#define SIZE 20u;
```

### 수식에 관한 규칙

* 단항 연산자의 바른 표기 : 피연산자와 붙여 써야 피연산자가 어떤 건지 금방 알 수 있음

```c++
// a ++ (X)
a++;
```

* 이항 연산자의 바른 표기 : 전후에 공백을 넣는 것이 좋음

```c++
a = b + c + d;
```

* 삼항 연산자의 바른 표기 : 알아보기 쉽게 맨 앞의 수식을 괄호(())로 묶어줌

```c++
// a>b ? x : -x; (X)
(a > b) ? x : -x;
```

* 증감 연산자의 바른 표기 : 다른 연산자와 섞어 사용하지 않는 것이 좋음

```c++
++eng;
sum = kor + eng;
```

* 연산자가 3개 이상인 경우 바른 표기 : 우선순위를 쉽게 알 수 있도록 괄호로 묶어주는 것이 좋음

```c++
if ((a == 0) && (b == 0))
```

* sizeof 인자의 바른 표기 : 수식을 sizeof 함수의 인자에 사용하지 않음

```c++
// sizeof(a=b+c) (X)
sizeof(a)
```

### 문장에 관한 규칙
* switch 문에서 case 문을 빠져나오기 위해 break 문을 사용
  * **switch-case문장에서 case문에 break문이 없는 경우 주석을 작성**
* switch 문에서 case 문이 다 끝나면 default 문을 넣어주어야 함
* **goto 문을 사용하지 않음**
* for 문을 제어하는 수식에 실수 값을 사용하지 않음
* for 문을 제어하는 수치 변수를 바르게 사용
    * for 문을 제어하는 수치 변수는 반복 횟수를 나타내므로 원래의 용도로만 사용해야 함
* break 문은 가능한 한 번만 사용
    * 반복문 안에서 반복 중단하기 위핸 break가 여러 개 사용되면 동작을 예측하기 어려움
* if ~ else 문의 끝은 else 문으로 종료

### Naming Convention

* 명명 규칙, 네이밍 컨벤션, 네이밍 규칙, 네이밍 규약, 명명 규약
  * 식별자의 명칭이 되는 문자열을 결정하기 위한 규칙
  * 목적: 가독성, 시인성, 효율성
  * 프로젝트, 프로그래밍 언어, 개발도구 등에 따라 달라질 수 있음

* **카멜 케이스(camelCase)**
  * 단봉낙타 표기법
  * 각 단어의 첫 문자를 대문자로 표기하고 붙여쓰되, 맨 처음 문자는 소문자로 표기

```java
int thisIsCamelCase = 0;
```

* **파스칼 케이스(PascalCase)**
  * 첫 단어를 대문자로 시작하는 표기법

```java
int ThisIsPascalCase = 0;
```

* **스네이크 케이스(snake_case)**
  * 단어를 밑줄문자로 구분하는 표기법

```java
int this_snake_case = 0;
```

* **케밥 케이스(kebab-case)**
  * 하이픈으로 단어를 연결하는 표기법
  * HTML5 태그의 id, class 속성으로 흔히 쓰임

```css
.this-is-kebab-case {
    ...
}
```

* **헝가리안 표기법(Hungarian Notation)**
  * 형식은 camelCase와 같지만, 맨 앞의 단어가 자료형을 나타내는 접두어

```java
String strName;
boolean bBusy;
int nAge;
```

### 추가 정리 - 린트

* **린트(lint) 또는 린터(linter)는 소스 코드를 분석하여 프로그램 오류, 버그, 스타일 오류, 의심스러운 구조체에 표시(flag)를 달아놓기 위한 도구들을 가리킴**([위키](https://ko.wikipedia.org/wiki/%EB%A6%B0%ED%8A%B8_(%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4)))
  * C 언어 소스 코드를 검사하는 Unix 유틸리티에서 기원함
* [Javascript 린터 - ES Lint](https://eslint.org/)

### 참고자료
* [프로그램 표준 코딩 규칙 - 행정안전부](https://github.com/ohbokdong/SoftwareEngineeringStudy/blob/master/summary/doc/%ED%96%89%EC%A0%95%EC%95%88%EC%A0%84%EB%B6%80_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%20%ED%91%9C%EC%A4%80%20%EC%BD%94%EB%94%A9%EA%B7%9C%EC%B9%99.pdf)