# 상위 설계
## 1. 설계의 이해

### 좋은 설계의 조건
- 요구 분석 명세서의 내용을 설계서에 모두 포함해야 한다.
- 유지보수가 용이하도록 추적이 가능해야 한다.
- 변화에 쉽게 적응할 수 있어야 한다.
- 시스템 변경으로 인한 영향이 최소화되도록 국지적이어야 한다.
- 설계서는 읽기 쉽고, 이해하기 쉽게 작성해야 한다.
- 결국 모듈이 독립적이어야 하고, 모듈 내 요소들간의 응집력은 높게 설계되어야 하며 결합력은 낮게 설계되어야 한다.

### 설계의 종류
- 상위 설계: 예비설계(preliminary design)라고도 함
    - 아키텍처(구조) 설계: 시스템의 전체적인 구조
    - 데이터 설계: 시스템에 필요한 정보를 자료구조와 데이터베이스 설계에 반영
    - 시스템 분할: 전체 시스템을 여러 개의 서브시스템으로 나눈다
    - 인터페이스 정의: 시스템의 구조와 서브시스템들 사이의 인터페이스가 명확히 정의된다
    - 사용자 인터페이스 설계: 사용자가 익숙하고 편리하게 사용할 수 있도록 사용자 인터페이스를 설계한다
- 하위설계: 내부 구조를 상세히 나타내는 것과 유사
    - 각 모듈의 실제적인 내부를 알고리즘(pseudo-code)형태로 표현
    - 인터페이스에 대한 설명, 자료구조, 변수 등에 대한 상세한 정보를 작성
<hr>

## 2. 설계의 원리

### 분할과 정복
- 가장 세분화된 작은 시스템을 개발하고, 하나씩 위로 올라가면서 완성시키는 방법으로 개발하는 것
- 분산 시스템은 클라이언트와 서버로 분할
- 시스템은 여러 서브시스템으로 분할
- 서브시스템은 하나 이상의 패키지로 분할
- 패키지는 여러 클래스로 분할
- 클래스는 여러 메서드로 분할
- 무작정 작게 쪼개면 통신으로 인한 복잡도가 증가되므로 증가 비용과 처리의 용이성을 고려하여 결정

### 추상화
- 추상화(abstraction)란 문제에서 현재의 관심사에 초점을 맞추기 위해 특정한 목적과 관련된 필수 정보만 추출하여 강조하고 관련이 없는 세부 사항을 생략함으로 본질적인 문제에 집중할 수 있도록 하는 작업
- 객체지향에서의 추상화: 객체들의 공통점을 뽑아 클래스라는 이름을 붙여놓은 것
- 종류
    - 과정 추상화(procedure abstraction)
    - 데이터 추상화(data abstraction)
    - 제어 추상화(control abstraction)

#### 과정 추상화
- 상세 부분은 생략하고 전체 흐름만 파악할 수 있는 알고리즘 형태로 작성하는 것
- ex) 버블/퀵 등 언급 x, '정렬한다'
- ex) 합계구하는 함수 - GetSum()

#### 데이터 추상화
- 데이터와 메서드를 클래스 형태로 캡슐화하여 숨겨놓고, 사용자에게는 꼭 필요한 기능만 사용할 수 있게 개방한 구조

#### 제어 추상화
- 단계가 올라갈수록 표현이 더욱 간결해지고 특징만 나타나게 됨
- ex) 고급언어 | 어셈블리 언어 | 기계 언어 표현

### 단계적 분해
- 하향식 설계에서 사용되며, 기능을 점점 작은 단위로 나누어 점차적으로 구체화하는 방법

### 모듈화
- 실제로 개발할 수 있는 작은 단위로 나누는 것
- 모듈의 특징
    - 다른 것들과 구별될 수 있는 독립적인 기능을 갖는 단위(unit)
    - 유일한 이름
    - 독립적 컴파일 가능
    - 모듈에서 또다른 모듈 호출 가능
    - 다른 프로그램에서도 모듈 호출 가능
- 모듈은 완전한 독립 프로그램
- 모듈의 형태
    - 용도가 비슷: 라이브러리 함수, 그래픽 함수
    - 추상화된 자료, 서브루틴(subroutine), 프로시저(procedure), 객체 메서드(method)
<hr>

## 3. 소프트웨어 아키텍처(Software architecture)
- 대규모 소프트웨어를 개발할 때의 복잡성 해결 방법
    - 개발할 소프트웨어의 전체 구조를 가장 먼저 생각한다
    - 그 구조를 이루는 각 구성 요소를 찾는다
    - 각 구성 요소들 간의 명확한 관계를 설정한다
    - 일정한 규칙을 따른다
- 즉 잘 정의된 전체적인 구조와 품질 좋은 소프트웨어를 만들려면 소프트웨어 아키텍처가 필요!

### 아키텍처의 특징과 기능
- 소프트웨어 아키텍처: 외부에서 인식 할 수 있는 특성이 담긴 소프트웨어의 골격이 되는 기본구조, 시스템 전체에 대한 밑그림
- 그 외 소프트웨어 아키텍처 정의
    - 구성 요소
    - 구성 요소들 사이의 관계
    - 구성 요소들이 외부에 드러내는 속성
    - 구성 요소들과 주변 환경 사이의 관계
    - 구성 요소들이 제공하는 인터페이스
    - 구성 요소들의 협력 및 조립 방법
- 소프트웨어 아키텍처의 공통 특징
    - 개발할 소프트웨어의 전체적인 구조를 다룬다
    - 소프트웨어를 이루고 있는 여러 구성 요소(서브시스템, 컴포넌트)를 다룬다
    - 구성 요소들이 인터페이스를 통해서 어떻게 상호작용하는지를 정의해야 한다
    - 세부 내용보다는 중요한 부분만을 다룬다
    - 시스템 설계와 개발 시 적용되는 원칙과 지침이 있어야 한다
- 소프트웨어 아키텍처 설계 고려사항
     - 의사소통 도구로 활용할 수 있어야 한다
     - 구현에 대한 제약 사항을 정의해야 한다
     - 품질 속성(성능성, 사용성, 보안성, 안전성, 검증성, 변경성 등)을 결정해야 한다
     - 재사용할 수 있게 설계해야 한다

## 아키텍처의 품질 속성
### 시스템 품질 속성
- 가용성(availability): 시스템이 운용될 수 있는 확률, 장애 발생 없이 서비스를 제공할 수 있는 능력
    - 가용성이 중요한 품질 속성이라면 이중화처럼 여분의 구성 요소를 포함하도록 설계
- 변경용이성(modifiablity): 변경 요구사항 발생 시 쉽게 변경할 수 있는 능력
- 성능(performance): 이벤트 발생 시, 빠르고 적절하게 반응할 수 있는 능력
- 보안성(security): 허용되지 않은 접근에 대응할 수 있는 능력
- 사용성(usability): 사용하는 순간에 혼란스럽지 않고 고민하지 않게 하는 편의성
- 테스트용이성(testability): 요구 기능에 대하여 쉽고 철저하게 테스트할 수 있는지

### 비즈니스 품질 속성
- 시장적시성(time to market): 정해진 날짜에 소프트웨어를 출시해 경쟁력을 높일 수 있는 정도
- 비용과 이익(cost and benefit): 더 들여 효과적일 것이냐, 비용을 절약할 것이냐
- 예상 시스템 수명(predicted lifetime of the system)
    - 이것이 중요한 경우라면, 변경 용이성, 확장성, 이식성을 중요하게 고려해야 함
- 목표 시장(targeted market)
    - 기능성, 이식성 등을 충분히 고려
- 신규 판매 일정 또는 공개 일정(rollout schedule)
- 기존 시스템과의 통합(integration with legacy system)

### 이해 관계자별 품질 속성
- 발주자 관점: 개발비 적은 업체
- 사용자 관점: 사용하기 쉽고 빨리 이해
- 개발자 관점: 변경 용이성

### 아키텍처 구축 절차
1. 요구 사항 분석
- 요구 사항 취득, 식별, 명세, 분류, 검증
- 기능적/비기능적 요구사항 분류 및 명세
2. 아키텍처 분석
- 품질 속성 식별, 우선 순위 결정, 품질 속성 반영 방법 개발
3. 아키텍처 설계
- 관점 정의(이해관계자 별)
- 아키텍처 스타일 (pipe-filter, MVC, layering 등)
- 후보 아키텍쳐 도출 (SAD-Software Architecure Description 기술, 관점별 다이어그램 등)
4. 검증 및 승인
- 아키텍처 평가
- 아키텍쳐 상세화
- 아키텍쳐 승인

![UML4+1관점](https://slidesplayer.org/slide/14653385/90/images/36/5.+%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98%EC%9D%98+4%2B1+%EA%B4%80%EC%A0%90%282%29.jpg)

### 아키텍처 스타일
[보편적 아키텍처 스타일의 장점]
- 개발 시간 단축, 고품질의 소프트웨어 생산
- 수월한 의사소통
- 용이한 유지보수
- 검증된 아키텍처
- 구축 전 시스템 특성에 대한 시뮬레이션 가능
- 기존 시스템에 대한 빠른 이해

[아키텍처 스타일의 기능]
- 소프트웨어 시스템의 구조를 체계적으로 구성하기 위해 기본 스키마 제시
- 미리 정의된 서브시스템 제공
- 각 아키텍처 패턴 간 책임 명시
- 패턴 간의 관계를 조직화하는 규칙, 가이드라인 제시
- 문제를 소프트웨어 모듈 단위로 분해하는 방법 제시
- 분해한 소프트웨어 모듈 단위가 상호작용하는 방법을 제시

### 아키텍처 모델
![아키텍처 모델의 분류](https://slidesplayer.org/slide/14653385/90/images/43/7.+%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98+%EB%AA%A8%EB%8D%B8.jpg)

#### 데이터 중심형 모델
![데이터중심형모델](https://slidesplayer.org/slide/14653385/90/images/44/7-1+%EB%8D%B0%EC%9D%B4%ED%84%B0+%EC%A4%91%EC%8B%AC%ED%98%95+%EB%AA%A8%EB%8D%B8%281%29+repository+model+%ED%8A%B9%EC%A7%95%3A+%EC%A3%BC%EC%9A%94+%EB%8D%B0%EC%9D%B4%ED%84%B0%EA%B0%80+repository%EC%97%90%EC%84%9C+%EC%A4%91%EC%95%99+%EA%B4%80%EB%A6%AC.jpg)
![데이터중심형모델의](https://slidesplayer.org/slide/14653385/90/images/45/7-1+%EB%8D%B0%EC%9D%B4%ED%84%B0+%EC%A4%91%EC%8B%AC%ED%98%95+%EB%AA%A8%EB%8D%B8%282%29+%EC%9E%A5%EC%A0%90+%EB%8B%A8%EC%A0%90+%EB%8D%B0%EC%9D%B4%ED%84%B0%EA%B0%80+%ED%95%9C%EA%B5%B0%EB%8D%B0%EC%97%90+%EB%AA%A8%EC%97%AC+%EC%9E%88%EA%B8%B0+%EB%95%8C%EB%AC%B8%EC%97%90+%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC+%EB%AA%A8%EC%88%9C%EB%90%98%EC%A7%80+%EC%95%8A%EA%B3%A0+%EC%9D%BC%EA%B4%80%EC%84%B1+%EC%9E%88%EA%B2%8C+%EA%B4%80%EB%A6%AC+%EA%B0%80%EB%8A%A5.jpg)

#### 클라이언트-서버 모델
![클라이언트서버모델](https://slidesplayer.org/slide/14653385/90/images/46/7-2+client-server+%EB%AA%A8%EB%8D%B8+Client-server+%EB%AA%A8%EB%8D%B8+%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%EB%A5%BC+%EC%9D%B4%EC%9A%A9%ED%95%98%EB%8A%94+%EB%B6%84%EC%82%B0+%EC%8B%9C%EC%8A%A4%ED%85%9C+%ED%98%95%ED%83%9C.jpg)

#### 계층 모델
![계층모델](https://slidesplayer.org/slide/14653385/90/images/47/7-3+%EA%B3%84%EC%B8%B5+%EB%AA%A8%EB%8D%B8+layering+%EB%AA%A8%EB%8D%B8+%EA%B8%B0%EB%8A%A5%EC%9D%84+%EB%AA%87+%EA%B0%9C%EC%9D%98+%EA%B3%84%EC%B8%B5%EC%9C%BC%EB%A1%9C+%EB%82%98%EB%88%84%EC%96%B4+%EB%B0%B0%EC%B9%98.jpg)

#### MVC 모델
![MVC1](https://slidesplayer.org/slide/14653385/90/images/48/7-4+MVC+%EB%AA%A8%EB%8D%B8%281%29+Model%2FView%2FController+%EB%AA%A8%EB%8D%B8+%EC%A4%91%EC%95%99+%EB%8D%B0%EC%9D%B4%ED%84%B0+%EA%B5%AC%EC%A1%B0.jpg)
![mvc2](https://slidesplayer.org/slide/14653385/90/images/49/7-4+MVC+%EB%AA%A8%EB%8D%B8%282%29+Model+%EC%84%9C%EB%B8%8C%EC%8B%9C%EC%8A%A4%ED%85%9C+View+%EC%84%9C%EB%B8%8C%EC%8B%9C%EC%8A%A4%ED%85%9C+Controller+%EC%84%9C%EB%B8%8C%EC%8B%9C%EC%8A%A4%ED%85%9C.jpg)
![MVC3](https://slidesplayer.org/slide/14653385/90/images/50/7-4+MVC+%EB%AA%A8%EB%8D%B8%283%29+%EC%9E%A5%EC%A0%90.+%EA%B4%80%EC%8B%AC%EC%9D%98+%EB%B6%84%EB%A6%AC.+%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC+%ED%99%94%EB%A9%B4%EC%97%90+%ED%91%9C%ED%98%84%28%EB%B7%B0%29%ED%95%98%EB%8A%94+%EB%94%94%EC%9E%90%EC%9D%B8%EA%B3%BC+%EB%A1%9C%EC%A7%81%28%EB%AA%A8%EB%8D%B8%29%EC%9D%84+%EB%B6%84%EB%A6%AC%ED%95%A8%EC%9C%BC%EB%A1%9C%EC%8D%A8+%EB%8A%90%EC%8A%A8%ED%95%9C+%EA%B2%B0%ED%95%A9+%EA%B0%80%EB%8A%A5.+%EA%B5%AC%EC%A1%B0+%EB%B3%80%EA%B2%BD+%EC%9A%94%EC%B2%AD+%EC%8B%9C+%EC%88%98%EC%A0%95+%EC%9A%A9%EC%9D%B4.+%EB%8B%A8%EC%A0%90..jpg)

#### 데이터 흐름 모델
![데이터흐름](https://slidesplayer.org/slide/14653385/90/images/51/7-5+%EB%8D%B0%EC%9D%B4%ED%84%B0+%ED%9D%90%EB%A6%84+%EB%AA%A8%EB%8D%B8+Pipe+and+filter+%EA%B5%AC%EC%A1%B0.jpg)