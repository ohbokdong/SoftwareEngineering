## Chapter 06. 하위설계
### 01. 모듈화 </br>
: 해결하기 어려운 큰 문제를 작은 단위로 쪼개 하나씩 해결하는 것처럼, 소프트웨어 개발 작업을 실제로 개발할 수 있는 작은 단위로 나누는 것 </br>
</br>
<특징>
* 모듈 간의 결합은 느슨하게 한다.
* 모듈 내 구성 요소들 간의 응집은 강하게 한다. </br>

<장점>
* 분할과 정복의 원리가 적용되어 복잡도 감소
* 유지보수 용이
* 오류로 인한 파급효과 최소화할 수 있다.
* 설계 및 코드를 재활용할 수 있다. 

### 02. 응집도 (높을 수록 좋음!)</br>
: 모듈 내부에 존재하는 구성 요소들 사이의 밀접한 정도로, 하나의 모듈 안에서 구성 요소들 간에 똘똘 뭉쳐 있는 정도로 평가한다. 응집도가 높을수록 구성 요소들이 꼭 필요한 것들로만 모여있고, 응집도가 낮을수록 서로 관련성이 적은 요소들이 모여있다. 


### 03. 결합도 (낮을 수록 좋음!) </br>
: 모듈과 모듈 사이의 관계에서 관련 정도를 나타낸다.</br> 
: 모듈 간에는 관련이 적을수록 상호 의존성이 줄어 모듈의 독립성이 높아짐</br>
: 독립성이 높으면 모듈간에 영향이 적어 좋은 설계가 됨.</br>


### 04. 모듈 간의 좋은 관계 </br>
: 모듈 간에는 꼭 필요한 데이터만 주고받는 것이 좋다. 그러려면 제어 플래그보다는 데이터를 매개변수로 사요한느 것이 좋다. 그래야 유지보수 용이성을 높일 수 있다. 설계를 할 때 가장 좋은 형태는 모듈 간의 결합도는 낮게, 응집도는 높게 하는 것이다.

### 05. 프로세스 지향 방법의 특징 </br>
* <b>프로세스와 데이터가 분리되어 있다</b> : 프로세스와 데이터가 각각 별개의 것으로 파악되고 분리되어 구조가 매우 복잡하며 유지보수가 어렵다.  
* <b>실세계를 컴퓨터 처리 방식으로 표현한다</b>: 실세계를 원래의 형태(속성과 조작이 함께 구성됨)가 아니라 컴퓨터가 처리하는 방식으로 변환해 표현한다. 그로 인해 결과가 왜곡될 수 있다. 
* <b>함수 중심(우선)으로 모듈을 구성한다</b>: 모듈을 구성할 때 처리의 중심이 되는 함수가 우선 결정된다. 함수를 중심으로 모듈이 구성되므로 시스템이 함수들의 모임인 모듈로 이루어지고 데이터들은 별도로 존재하게 된다. 


### 06. 프로세스 지향 방법과 데이터 지향 방법의 문제점
* 변경이 미치는 영향이 크다.
* 프로그램 복잡도가 증간한다.
* 프로그램 변경 시 프로그램 구조를 상세히 파악해야 한다.
* 재사용이 어렵다.

### 07. 객체지향 방법
: 프로세스 지향 방법과 데이터 지향방법의 문제점을 해결하기 위해 고안됨. </br>
: 기능이나 데이터 대신 객체가 중심이 되어 개발</br>
: 데이터(속성) + 데이터 조작하는 메서드 = 객체 -> 객체를 중심으로 모듈 구성</br>
: 즉, 객체 속에는 기능과 데이터가 모두 포함되어야 함</br>
![객체지향방](https://github.com/ohbokdong/SoftwareEngineeringStudy/blob/master/summary/img/week6/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%20%EB%B0%A9%EB%B2%95.jpg)

### 08. 클래스
: 공통되는 것들을 묶어서 대표적인 이름을 붙인 것.
: 데이터 및 이 데이터에서 수행되는 메서드까지 포함
: 클래스 (개념적) / 객체 (구체적)

### 09. 인스턴스
: 같은 클래스에 속하는 개개의 객체로 하나의 클래스에서 생성된 객체를 말함</br>
: 클래스에서 정의된 속성와 성질을 가진 실제적인 객체로 표현된 것 의미</br>

### 10. 캡슐화
: 사용자들에게 해당 객체의 기능(서비스)과 사용법만 제공하고 내부는 감추어(변경할 수 없게 함) 쉽게 사용할 수 있게 하는 개념이다.</br> 
<장점></br>
* <b>데이터 보호</b>: 이용자가 데이터에 직접 접근하는 것을 차단하므로 객체 내 데이터 및 코드의 손상과 오용을 막고 안전하게 보호할 수 있다. 
* <b>추상화 용이</b>: 추상화를 통해 프로그래밍 문제를 쉽게 개념화 할 수 있다. 
* <b>제공자와 이용자를 명확히 분리</b>: 객체 제공자와 객체 이용자 (외부 객체)의 분담을 명확히 할 수 있다. 
* <b>이용자에게 편리성 제공</b>: 메서드의 구현 방법이 바뀌어도 (예, 버블 정렬이 퀵 정렬로 바뀜)이를 사용하는데 어려움이 없다. 
* <b>사용법이 쉬움</b>: 세탁기 버튼의 기능만 알면 사용할 수 있는 것처럼, 메서드의 기능만 알면 객체를 사용할 수 있다. 
* <b>변화에 대한 국지적 영향</b>: 객체 내의 데이터 구조가 바뀌어도 다른 객체에는 영향을 주지 않는다. 
* <b>객체 간의 독립성 보장</b>: 캡슐화(데이터 + 메서드)로 인해 객체 사이의 독립성이 구조적으로 보장된다.
* <b>변경 용이성과 재사용성 증대</b>: 설계의 변경 용이성과 재사용성을 높여준다. 


### 11. 정보은닉
: 한 모듈에서 인터페이스와 구현을 명확히 분리하여 각 모듈의 내부 항목에 관한 정보는 감추고,인터페이스를 통해서만 메시지를 전달함으로써 다른 모듈을 변경하지 못하도록 한다. 
: 접근 지정자 사용 (public/ private/ protected) </br>
<특징></br>
* <b>블랙박스 역할</b>: 데이터와 메서드를 숨기는 장치, 객체의 사용자와 사용자와 제공자의 역할을 명확히 분리해준다.
* <b>인터페이스를 통한 접근</b>: 사용자가 공개 인터페이스를 사용함으로써 객체 내부의 자료구조를 몰라도 객체를 쉽게 이용할 수 있다. 사용자는 모듈의 구현 형태 (삽입 정렬, 버블 정렬 등)를 몰라도 인터페이스를 통한 사용법만 알면 쉽게 이용할 수 있다.
* <b>자료구조 변경이 용이</b>: 제공자가 객체 내부의 자료구조를 변경해도 (버블 정렬을 퀵 정렬로 변경) 그 객체와 인터페이스를 통해 통신하는 사용자에게는 영향을 주지 않으므로 부담없이 자료 구조를 변경할 수 있다. 즉 사용자는 인터페이스만 바뀌지 않는다면 호출하는 모듈은 종전대로 사용할 수 있다. 

<장점></br>
* <b>독립성 향상</b>: 다른 모듈과 관계가 적어 모듈의 독립성을 높여준다.
* <b>수정 용이</b>: 기능을 중심으로 하는 프로세스 지향 방식에서는 다른 모듈에 미치는 영향을 충분히 검토한 후에 모듈을 수정해야 한다. 그러나 객체지향의 정보은닉 개념을 적용하면 인터페이스가 바뀌지 않는 한 다른 모듈에 미치는 영향을 고려할 필요가 없다.
* <b>이해도 증진</b>: 프로그램을 개발할 때 다른 모듈의 구현 내용을 자세히 알 필요 없이 제공하는 기능만 알면 메시지를 통해 사용할 수 있어 프로그래머가 모듈을 이해하기가 쉽다. 
* <b>확장성 증가</b>: 모듈 내의 데이터와 알고리즘을 변경하기 쉬워 기능을 추가하기도 쉽다. 

### 12. 메서드 오버로딩
: 한 클래스에 이름이 동일한 메서드가 중복 정의되어 있는 경우를 메서드 오버로딩이라 한다. 

### 13. 메서드 오버라이딩
: 메서드 오버라이딩은 추상 클래스와 일반 클래스를 모두 다 사용할 수 있다. 또한 상위 클래스에서 정의한 일반 메서드의 구현을 하위 클래스에서 모두 무시하고 다시 재정의해서 사용할 수 있다. 

### 14. 연관관계
: 서로 알고 지내는 정도의 관계로 하나의 클래스가 또 다른 클래스를 인지하고 있음을 의미한다. 따라서 두 클래스는 서로 메시지를 주고 받으며 이용하는 관계가 된다. 

### 15. 일반화-특수화 관계 (IS-A 관계)
: 두 클래스 가의 상속 관계를 말한다. </br>
: 하위 클래스는 상위 클래스의 각 속성과 메서드를 모두 상속받아 사용한다. 즉 하위 클래스는 원래 가지고 있던 고유의 속성과 연산뿐 아니라 상위 클래스에서 물려받은 속성와 연산까지 모두 사용하게 된다.

### 16. 집합 관계와 포함 관계
: 집합 관계는 연관 관계를 더 구체적으로 나타낸 것으로, 거대한 객체 하나를 소규모 객체 여러개로 구성할 때 발생할 수 있다. 즉 전체 부분 관계가 성립한다. 

### 17. 클래스 설계 원칙
* <b>단일 책임 원칙</b>: 클래스를 변경해야하는 이유는 오직 하나여야 한다. 즉, 클래스는 한 가지 기능만 갖도록 설계하자.
* <b>개방 폐쇄의 원칙</b>: 확장(상속)에는 열려 있어야 하고 변경에는 닫혀있어야 한다. 
* <b>리스코프 교체의 원칙</b>: 기반 클래스는 파생 클래스로 대체할 수 있어야 한다. 
* <b>의존 관계 역전의 원칙</b>: 클라이언트는 구체 클래스가 아닌 추상 클래스(인터페이스)에 의존해야 한다. 
* <b>인터페이스 분리의 원칙</b>: 하나의 일반적인 인터페이스보다는 구체적인 여러 개의 인터페이스가 낫다. 즉, 클라이언트는 자신이 사용하지 않는 메서드와 의존관계를 맺으면 안된다.


그러나 전체 객체에 완전히 전속되어 독립된 객체로 존재할 수 없는 부분 객체도 있는데, 이와 같은 관계를 특별히 포함 관계라고 한다. 포함 관계의 부분 객체들은 전체 객체가 없어지면 같이 없어진다. 
